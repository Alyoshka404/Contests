# Yandex contest
<br>

## Довольные аналитики

В Яндексе есть два аналитика — Ян и Петр. Каждый день они берутся за новую задачу. Ян получает удовольствие от работы, если сделал 2 задачи подряд успешно. А Петр — только когда после проваленной задачи в следующей добился успеха.

На сколько дней в среднем Яну ждать первого удовольствия дольше, чем Петру (успех и провал по каждой задаче равновероятны)?

**Формат вывода:**
В ответе напишите число, округлив до двух знаков после запятой. Ответ может быть отрицательным.

**Пример:** -8.68

### **Решение:**

Рассмотрим возможные варианты успехов для Яна и Петра при помощи изображения событий через древо вероятночтей. Можно заметить, что у Петра число успешых событий на `n день` будет `n-1`. Всего событий на `n день` будет `2^n` (или же `2*n` при условии, что после успеха ветвь будет прерываться).

У Яна количество успешных событий будет другим на `n день`. Расписав древо вероятностей можно заметить, что число успехов возрастает с каждым днём по последовательности Фибоначчи, т.е. на `n = 1, N = 0`, `n = 2, N = 1`, `n = 3, N = 1`, `n = 4, N = 2`, `n = 5, N = 3`, `n = 6, N = 5`, `n = 7, N = 8` и т.д. , где `N - число успешных событий`.

Для того, чтобы узнать сколько в среднем дней проходит, чтобы один из аналитиков получил удовольствие от работы, необходимо найти предел суммы последовательности. Т.е. находим `lim(∑[P(n)*n])`. Это конечные последовательности, для ответа необходимо будет найти разницу наших результатов.

Если брать количество событий как `2*n` последовательность будет возрастающей, поэтойму всего событий следует брать `2^n`.

**Ян:**

>```python
>def func_jan(n):
>    p = (n-1)/2**n
>    return (p*n)
>```

Предел последовательности:

>```python
>def lim_jan(a = None):
>    n = 2
>    res = 0
>    res_before = -1
>    while res - res_before > 0.01:
>        res_before = res
>        res += func_jan(n)
>        n += 1
>    return round(res)
>```

Получаем:

>```python
>lim_jan()
>output: --> 4
>```

**Петр:**

Функция для определения числа последовательности Фибоначчи по номеру рабочего дня:

>```python
>def fib(n):
>    fib1 = 0
>    fib2 = 1
>    if n == 2:
>        return fib2
>    for i in range(2, n):
>        fib2 = fib2 + fib1
>        fib1 = fib2 - fib1
>   return fib2
>```

>```python
>def func_peter(n):
>    p = fib(n)/2**n
>    return (p*n)
>```

Предел последовательности:

>```python
>def lim_peter(a = None):
>    n = 2
>    res = 0
>    res_before = -1
>    while res - res_before > 0.01:
>        res_before = res
>        res += func_peter(n)
>        n += 1
>    return round(res)
>```

Получаем:

>```python
>lim_peter()
>output: --> 6
>```

Получаем два числа и находим разницу в два дня, насколько дней в среднем Яну ждать первого удовольствия дольше, чем Петру.

***Ответ: 2***

---
<br>


## Футбол

Сотрудники Яндекса любят играть в мини-футбол по выходным. В каждом матче играют две команды по 5 человек. Состав на игру в каждую команду выбирается случайно равновероятно из всех сотрудников Яндекса.

Аркадий ведет статистику всех игр. Он записывает состав каждой команды и финальный счет игры. Кроме этого, он ведет статистику каждого игрока по разнице мячей: каждому игроку матча добавляется разница мячей команды, в составе которой он играл. Разница мячей считается как число голов cвоей команды минус число голов противоположной команды. Изначально статистика по разнице мячей для каждого игрока равна 0.

Помогите Аркадию понять его прогресс в сезоне. После каждого матча нужно посчитать количество игроков с разницей мячей больше, чем у Аркадия.

**Формат ввода**

В первой строке записано два числа: `N (10 ≤ N ≤ 10000)` - число сотрудников, `M (1 ≤ M ≤ 100000)` — число футбольных матчей. Затем следуют результаты каждого матча.

В первой строке каждого матча записано два числа, `gA, gB (0 ≤ gA, gB ≤ 20)` — количество голов, которые забили команды A и B.

Во второй строке каждого матча записаны десять чисел `pi (0 ≤ pi < N)` — id сотрудников, участвовавших в матче. Первые пять - состав команды A, вторые пять - состав команды B.

Гарантируется, что составы команд для каждого матча выбирались случайно равновероятно.

У Аркадия id всегда равно 0.

**Формат вывода:**
Для каждого футбольного матча выведите одно целое число — количество игроков с разницей мячей больше, чем у Аркадия.

```
Ввод
10 1
6 15
8 1 0 3 9 2 6 5 4 7 
```

```
Вывод
5
```

### **Решение:**

Для начала прочтём входные данные и поймём с чем будем работать:
```
fin = open('input_2.txt', 'r')
```

```python
fin.readlines() #для прочтения файла в виде листа

output --> ['20 3\n', '12 5\n', '4 8 12 7 3 6 2 0 1 17']
```
Поместим данные в один лист и удалим пропуски на концах строк и новые абзацы `\n`

```python
l = [i.rstrip() for i in fin.readlines()]

output --> ['20 3', '12 5', '4 8 12 7 3 6 2 0 1 17']
```

Число всех участников 
```python
n = int(l[0].split()[0])

output --> 20
```
Создам таблицу, куда удобно будет записывать все очки каждого участника

```python
import pandas as pd
df = pd.DataFrame([0]*n)
df.columns =['points']
```
Получаю:

```python
	points
0	0
1	0
2	0
3	0
4	0
5	0
6	0
7	0
8	0
9	0
10	0
11	0
12	0
13	0
14	0
15	0
16	0
17	0
18	0
19	0
```
Выпишем результаты матча 
```python
a_points = int(l[1].split()[0])
b_points = int(l[1].split()[1])
output --> 12
output --> 5
```
Находим модуль разности финального счёта игры и прибавляем к счёту каждого игрока, участвовавшего в матче:

```python
delta = abs(a_points - b_points)
output --> 7
if a_points >= b_points:
  for i in range(5):
    n = int(l[2].split()[i])
    df['points'][n] += delta
else: 
  for i in range(5, 10):
    n = int(l[2].split()[i])
    df['points'][n] += delta
```
Получаем:

```python
	points
0	0
1	0
2	0
3	7
4	7
5	0
6	0
7	7
8	7
9	0
10	0
11	0
12	7
13	0
14	0
15	0
16	0
17	0
18	0
19	0
```
Определим сколько человек опережают Аркадия по очкам:

```python
df[df['points']>df['points'][0]]['points'].count()

output --> 5
```

Мы сделали задачу для одного матча, но количество матчей дано во входящих данных:

```python
m = int(l[0].split()[1])

output --> 3
```

Если даны все строки с результатами и участниками, тогда нужно взять прерыдущий расчёт по количеству сыгранных матчей, то есть:


```python
for j in [i for i in list(range(2*m)) if not i%2]:
  a_points = int(l[j+1].split()[0])
  b_points = int(l[j+1].split()[1])

  delta = abs(a_points - b_points)
  
  if a_points >= b_points:
    for i in range(5):
      n = int(l[j+2].split()[i])
      df['points'][n] += delta
  else: 
    for i in range(5, 10):
      n = int(l[j+2].split()[i])
      df['points'][n] += delta

c = df[df['points']>df['points'][0]]['points'].count()
```
 Если же входных данных нет, то из условия можно сделать следующее:
 
```python
import random

if m > 1:
  for k in range(m-1):
    list_players = random.sample(list(range(n)), 10)
    print(list_players, 'матч', k+2)
    
    a_points = random.randint(0, 20)
    b_points = random.randint(0, 20)
    print (a_points, ' ', b_points)
    
    delta = abs(a_points - b_points)
    
    if a_points >= b_points:
      for i in range(5):
        n = int(list_players[i])
        df['points'][n] += delta
    else: 
      for i in range(5, 10):
        n = int(list_players[i])
        df['points'][n] += delta

c = df[df['points']>df['points'][0]]['points'].count()
```

Для примера получаем таблицу:
 
```python
	points
0	0
1	9
2	0
3	7
4	7
5	6
6	0
7	22
8	22
9	0
10	9
11	0
12	7
13	6
14	9
15	0
16	0
17	0
18	0
19	6
```
 И ответ для данного ввода:
 
```python
c = df[df['points']>df['points'][0]]['points'].count()

output --> 11
```

---
<br>


## Экономный инженер

Молодой инженер Сергей решил накопить денег на новую авиамодель. Подсчитав стоимость всех необходимых ему частей и вычтя их из зарплаты, Сергей понял, что в месяц может потратить не больше 10000 монет. Чтобы следить, что он не тратит слишком много, Сергей решил записывать каждый свой расход и считать, сколько у него останется от 10000 монет, если в оставшееся время он будет тратить в минуту столько же, сколько в среднем тратил до сих пор. Помогите Сергею написать программу, которая будет считать это за него.

**Формат ввода**

На вход подаются от 1 до 10000 строк. Каждая строка имеет формат

`YYYY-MM-DD hh:mm:ss S`

Здесь `YYYY-MM-DD` - год-месяц-число, когда был расход, `hh:mm:ss` - час:минута:секунда, когда был расход, S - количество потраченных монет.

Время расхода `T` изменяется в рамках (`2021-01-01 00:00:00 ≤ T ≤ 2021-01-31 23:59:59`).

Сумма расхода `S` - это целое число: `1 ≤ S ≤ 1000`.

Строки подаются на вход в порядке не убывания времени расхода.

**Формат вывода:**

Для каждой строки на входе необходимо посчитать сумму, которая останется у инженера на момент времени `2021-02-01 00:00:00`, если инженер будет в среднем тратить столько же, сколько тратил до момента времени в строке включительно.

Сумму необходимо округлить банковским методом (например, round() в Python 3.7.3) и записать с двумя цифрами после запятой.

### Пример 1
```
Ввод
2021-01-01 00:00:00 1000
```

```
Вывод
-2678390000.00
```
### Пример 2
```
Ввод
2021-01-31 23:59:59 1000
```

```
Вывод
9000.00
```

### Пример 3
```
Ввод
2021-01-31 23:59:59 1000
2021-01-31 23:59:59 1000
```

```
Вывод
9000.00
8000.00
```

### Пример 4
```
Ввод
2021-01-24 05:59:59 1000
```

```
Вывод
8666.67
```

### **Решение:**

Отроем и сохраним в листе ввходные данные:

```python
fin = open('input_econ.txt', 'r')
list_base = [line.rstrip() for line in fin.readlines()]

output --> ['2021-01-31 23:59:59 1000', '2021-01-31 23:59:59 1000']
```

Импортируем библиотеку для удобства работы с временем (можно без неё, но придётся `split()` строки по разделителям, что очень объёмно)
```python
import datetime

spent_total = 0
total_time = 31*24*60

bank = 10000
spent_total_i = 0
total_time_i = 0
mean_spent_i = 0
total_spent_delta = 0

for i in range(len(list_base)):
	l_dt = list_base[i].split()[0]
    	dt_i = datetime.datetime.strptime(l_dt, '%Y-%m-%d %H:%M:%S')
	days_i = dt_i.day
    	hours_i = dt_i.hour
    	min_i = dt_i.minute
    	sec_i = dt_i.second
	
	time_before = total_time_i
    	total_time_i = ((days_i-1)*24 + hours_i)*60 + min_i + 1
	
    	spent_i = int(list_base[i].split()[1])
    	spent_total_i += spent_i
    
    	mean_before = mean_spent_i
    	mean_spent_i = spent_total_i/total_time_i
	
    	if i == 0:
        	delta_time = 0
    	else: 
        	delta_time = total_time_i - time_before
        
    	spent_delta = mean_before * delta_time
    	total_spent_delta += spent_delta    

delta_time_total = total_time - total_time_i
all_spent = spent_total_i + delta_time_total*mean_spent_i + total_spent_delta
all_spent = round(all_spent, 2)

result = bank - all_spent
result
output --> 8000.0
```
В цикле сохраняем поочерёдно результаты с переносом строк `\n` в каждой итерации и выводим как `output`

Количество дней в цикле сокращено на один по причите того, что сам месяц начинается с 1го числа, но сами сутки не прошли, поэтому число минут за сутки в пером дне месяца рассчитывается как `((day-1)*24 + hours)*60 + minutes + 1` к минуте прибавляем 1 по причине, что минута уже идёт независимо сколько секунд, первая минута любого времени идёт в счёт, хотя формально в дате может стоять `0` или же этой минуте осталась `1` секунда.

С первым вводом (***Пример 1***) ошибка вывода. Для совпадения результатов необходимо учитывать не минуты, а секунды и только в общем времени за весь месяц вычета из общей суммы. То есть необходимо брать `total_time = 31*24*60 (* 60)`, тогда результат будет как на примере `-2678390000.00`

Для вывода можно использовать `f'{result:.2f}'`

---
<br>


## Расселение спортсменок

Спортивная школа по синхронному плаванию «Золотая рыбка» приехала в детский лагерь «Радость» для проведения летних сборов.
Прежде всего вожатым требуется расселить спортсменок по комнатам. Главный тренер предложил для расселения следующее правило: в комнату заселяют всю команду целиком и больше никого другого. Всего приехало `n` команд спортсменок.

Количество комнат заданной вместимости в лагере ограничено. Определите, получится ли у вожатых расселить детей?

**Формат ввода**

В первой строке задано число `n` – число команд спортсменок. Во второй строке записаны `n` чисел `ai` — количество количество спортсменок в `i`-й команде.
Далее следует число `k` – количество типов комнат, и `k` пар вида *вместимость комнаты, количество таких комнат.*

Все числа во входных данных положительные целые и не превосходят `10000`.


**Формат вывода:**

Выведите `Yes`, если у вожатых получится расселить спортсменок, и `No`, если не получится.

### Пример 1
```
Ввод
3
1 2 3
1
2 3
```

```
Вывод
No
```
### Пример 2
```
Ввод
3
1 2 3
1
3 2
```

```
Вывод
No
```

### Пример 3
```
Ввод
3
1 2 3
1
3 3
```

```
Вывод
Yes
```

### Пример 4
```
Ввод
3
1 2 3
4
1 1
2 1
3 1
4 1
```

```
Вывод
Yes
```

### Пример 5
```
Ввод
5
1 1 1 1 1
5
1 1
1 1
1 1
1 1
1 1
```

```
Вывод
Yes
```


### **Решение:**

Записываем входные данные. Удобнее использовать словари для записи данных. 

На вход будут записываться данные через `input()` , также можно сделать через текстовый файл `input.txt`, это незначительное изменение, разница только в работе с неразделённым списком из текстового файла (например через циклы `for` и длину входного листа `len()`)


```python
input()
teams = {}
for count in map(int, input().split()):
    teams[count] = teams.get(count, 0) + 1
rooms = {}
for _ in range(int(input())):
    capacity, quantity = map(int, input().split())
    rooms[capacity] = rooms.get(capacity, 0) + quantity
```

Пример:

```python
input --> 3
input --> 1 2 3
input --> 1
input --> 3 2

output --> teams = {1: 1, 2: 1, 3: 1}
output --> rooms = {3: 2}
```
То есть мы категоризировали входные данные по вместимости комнат `capacity` и количеству человек в команде `count`, записав всё в словари.

Получим список из кортежей (size, count) и отсортируем в порядке убывания
```python
teams = sorted(teams.items(), reverse =True)
rooms = sorted(rooms.items(), reverse =True)
output --> [(3, 1), (2, 1), (1, 1)]
output --> [(3, 2)]
```

Проводим проверку на вместимость комнаты всех спортсменок из максимальной команды, записав данные из первых кортежей в переменные
```python
team_size, team_count = teams.pop(0)
output --> team_size = 3
output --> team_count = 1

room_capacity, room_quantity = rooms.pop(0)
output --> room_capacity = 3
output --> room_quantity = 2
```
Проверка на вместимость:
```python
if team_size > room_capacity: 
	print ("No")  # return "No" - после перепишем это всё для функции
```
Если проверку на вместимость прошли, тогда выбираем минимальное количество таких команд или комнат и вычитаем их из общего числа комнат и команд (то есть минимум по размеру, который уже будет заселён, либо останутся команды этого размера, которые не заселены, либо комнаты, которые ещё пустуют.
```python
delta = min(team_count, room_quantity)
team_count    -= delta
room_quantity -= delta
```
И мы должны повторить это до тех пор, пока все команды команды не будут расселены или не закончатся комнаты:
```python
while (teams or team_count) and (rooms or room_quantity):
```
И последнее, необходимо чтобы мы брали новые кортежи из списков, только после обнуления предыдущего значения, значит до цикла примем их за 0
```python
def func_set(teams, rooms):

team_count = room_quantity = 0
while (teams or team_count) and (rooms or room_quantity):
	if team_count == 0: 
            team_size, team_count = teams.pop()
	if room_quantity == 0: 
            room_capacity, room_quantity = rooms.pop()
	if team_size > room_capacity: 
            return "No"
	    
	delta = min(team_count, room_quantity)
	team_count    -= delta
	room_quantity -= delta
```

И возвращаем `No`, если не смогли расселить всех спортсменок, иначе возвращаем `Yes`
```python
return "No" if teams or team_count else "Yes"
```

Объединяя всё в функцию, получим следующий результат:

```python
input()
teams = {}
for count in map(int, input().split()):
    teams[count] = teams.get(count, 0) + 1
rooms = {}
for _ in range(int(input())):
    capacity, quantity = map(int, input().split())
    rooms[capacity] = rooms.get(capacity, 0) + quantity

func_set(teams, rooms)
```

---
<br>


## Телешоу

В одном телевизионном шоу перед игроками стояла задача пройти 19 дверей в 19 стенах, расположенных друг за другом. В каждой стене было по две двери: при открытии одной из них на игрока выливалось ведро воды и он выбывал из игры, а при открытии второй мог идти к следующей стене. Игроки не знали, за какой из двух дверей на них выльется вода. «Проигрышные» двери были распределены случайно.

Когда игрок под номером N выбывал, следующий за ним игрок мог спокойно проходить до последней открытой двери, потому что видел выбор предыдущих игроков и выбирал двери, не ведущие к поражению.

Сколько игроков должно участвовать в игре, чтобы вероятность того, что хотя бы один игрок пройдёт все 19 стен была больше 0.95?

**Примечания**

В случае, если бы стена была всего одна, ответ был бы 2: одного игрока недостаточно, потому что он может ошибиться с выбором с вероятностью 1/2, но двух достаточно, потому что в случае ошибки первого, второй игрок будет знать правильную дверь и через неё пройдёт.



### **Решение:**

Вероятность пробежать правильно одну дверь составляет `0.5`, но второй участник будет иметь успех в `100%`, если первый неправильно выберет дверь.
Значит вероятность выиграть второму участнику составляет `0.5 * 1` того что первый допустит ошибку, то есть его успех - это неуспех предыдущего.

Получается если у нас `2` двери, первый сможет выиграть в случае, если открое обе двери верно, т.е. `0,5 * 0,5 = 0,5**2`. Второй же участник точно преодолеет первую дверь и останется вторая `0,5`, а вот выиграет он или нет, зависит от провала первого участника, т.е. его успех будет вероятностью провала первого. Вероятность провала это `1 - 0,5**2 = 0,75`, а вероятность провала второго участника как раз его успех (провал первого) умноженный на вероятность открытия всех оставшихся
дверей, вычтенных из единицы, т.е. `1 - 0,75*0,5` - это же есть вероятность успеха третьего участника, но в случае провала двух предыдущих он выигрывает с точность `100%` по причине, что дверей не останется.

Таким образом можно получить следующее решение задачи:

```python
n = 19
m = n
i = 0
prob = 1
k = 0
while prob >= 0.95:
    prob = (1-p**n) * prob
    n -= 1
    i += 1
    k = m - i +1
print(prob)
print(k)

print('Челевек пройдёт ', m, 'стен, под номером', 19-k, 'с вероятностью больше 95%')

output --> Челевек пройдёт  19 стен, под номером 14 с вероятностью больше 95%
```
То есть `14` человек будет иметь вероятность успеха выше `0,95`, потому что вероятность его провала ниже `0,95`

Это осуществляется по причине того, что тут напрямую успех победить зависит от вероятности проиграть человека перед тобой, так как мы не знаем сколько он дверей откроет точно. Поэтому если у участника появляется шанс победить в `2%`, это напрямую означает шанс проиграть следующего с вероятностью в `2%` и эта вероятность будет только расти.

```python
n = 19
m = n
prob = 1
k = 0
i = 0
for j in range(n):
    prob = (1-p**(m)) * prob
    m -= 1
    print(prob)
    if prob < 0.95:
        k = n - i
        break
    else:
        i += 1

print(prob)
print(n)
print(k)
print('--------------')
print(i)
```

```python
output:

0.9999980926513672
0.9999942779613775
0.999986648610502
0.9999713900251656
0.9999408733201477
0.9998798417727038
0.9997577861279562
0.9995137046372022
0.9990256608361099
0.9980500498391996
0.9961007333356074
0.9922097148460153
0.9844580764487808
0.9690759190042686
0.9387922965353852
0.9387922965353852
19
5
--------------
14
```

Число `k` показывает сколько человек осталось, то есть `N=19 k=1`, `N=18 k=2`, `N=17 k=3`, `N=16 k=4`, `N=15 k=5`. Получается при `k=6` номер участника будет `N=14` и он является на границе у кого вероятность поражения будет `0.938` что ниже `0,95`. Следовательно он будет победителем с вероятностью выше `0,95`.

***Ответ: 14***

---
<br>







