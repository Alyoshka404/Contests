# Yandex contest
<br>

## Довольные аналитики

В Яндексе есть два аналитика — Ян и Петр. Каждый день они берутся за новую задачу. Ян получает удовольствие от работы, если сделал 2 задачи подряд успешно. А Петр — только когда после проваленной задачи в следующей добился успеха.

На сколько дней в среднем Яну ждать первого удовольствия дольше, чем Петру (успех и провал по каждой задаче равновероятны)?

**Формат вывода:**
В ответе напишите число, округлив до двух знаков после запятой. Ответ может быть отрицательным.

**Пример:** -8.68

### **Решение:**

Рассмотрим возможные варианты успехов для Яна и Петра при помощи изображения событий через древо вероятночтей. Можно заметить, что у Петра число успешых событий на `n день` будет `n-1`. Всего событий на `n день` будет `2^n` (или же `2*n` при условии, что после успеха ветвь будет прерываться).

У Яна количество успешных событий будет другим на `n день`. Расписав древо вероятностей можно заметить, что число успехов возрастает с каждым днём по последовательности Фибоначчи, т.е. на `n = 1, N = 0`, `n = 2, N = 1`, `n = 3, N = 1`, `n = 4, N = 2`, `n = 5, N = 3`, `n = 6, N = 5`, `n = 7, N = 8` и т.д. , где `N - число успешных событий`.

Для того, чтобы узнать сколько в среднем дней проходит, чтобы один из аналитиков получил удовольствие от работы, необходимо найти предел суммы последовательности. Т.е. находим `lim(∑[P(n)*n])`. Это конечные последовательности, для ответа необходимо будет найти разницу наших результатов.

Если брать количество событий как `2*n` последовательность будет возрастающей, поэтойму всего событий следует брать `2^n`.

**Ян:**

>```python
>def func_jan(n):
>    p = (n-1)/2**n
>    return (p*n)
>```

Предел последовательности:

>```python
>def lim_jan(a = None):
>    n = 2
>    res = 0
>    res_before = -1
>    while res - res_before > 0.01:
>        res_before = res
>        res += func_jan(n)
>        n += 1
>    return round(res)
>```

Получаем:

>```python
>lim_jan()
>output: --> 4
>```

**Петр:**

Функция для определения числа последовательности Фибоначчи по номеру рабочего дня:

>```python
>def fib(n):
>    fib1 = 0
>    fib2 = 1
>    if n == 2:
>        return fib2
>    for i in range(2, n):
>        fib2 = fib2 + fib1
>        fib1 = fib2 - fib1
>   return fib2
>```

>```python
>def func_peter(n):
>    p = fib(n)/2**n
>    return (p*n)
>```

Предел последовательности:

>```python
>def lim_peter(a = None):
>    n = 2
>    res = 0
>    res_before = -1
>    while res - res_before > 0.01:
>        res_before = res
>        res += func_peter(n)
>        n += 1
>    return round(res)
>```

Получаем:

>```python
>lim_peter()
>output: --> 6
>```

Получаем два числа и находим разницу в два дня, насколько дней в среднем Яну ждать первого удовольствия дольше, чем Петру.

***Ответ: 2***

---
<br>


## Футбол

Сотрудники Яндекса любят играть в мини-футбол по выходным. В каждом матче играют две команды по 5 человек. Состав на игру в каждую команду выбирается случайно равновероятно из всех сотрудников Яндекса.

Аркадий ведет статистику всех игр. Он записывает состав каждой команды и финальный счет игры. Кроме этого, он ведет статистику каждого игрока по разнице мячей: каждому игроку матча добавляется разница мячей команды, в составе которой он играл. Разница мячей считается как число голов cвоей команды минус число голов противоположной команды. Изначально статистика по разнице мячей для каждого игрока равна 0.

Помогите Аркадию понять его прогресс в сезоне. После каждого матча нужно посчитать количество игроков с разницей мячей больше, чем у Аркадия.

**Формат ввода**

В первой строке записано два числа: `N (10 ≤ N ≤ 10000)` - число сотрудников, `M (1 ≤ M ≤ 100000)` — число футбольных матчей. Затем следуют результаты каждого матча.

В первой строке каждого матча записано два числа, `gA, gB (0 ≤ gA, gB ≤ 20)` — количество голов, которые забили команды A и B.

Во второй строке каждого матча записаны десять чисел `pi (0 ≤ pi < N)` — id сотрудников, участвовавших в матче. Первые пять - состав команды A, вторые пять - состав команды B.

Гарантируется, что составы команд для каждого матча выбирались случайно равновероятно.

У Аркадия id всегда равно 0.

**Формат вывода:**
Для каждого футбольного матча выведите одно целое число — количество игроков с разницей мячей больше, чем у Аркадия.

```
Ввод
10 1
6 15
8 1 0 3 9 2 6 5 4 7 
```

```
Вывод
5
```

### **Решение:**

Для начала прочтём входные данные и поймём с чем будем работать:
```
fin = open('input_2.txt', 'r')
```

```python
fin.readlines() #для прочтения файла в виде листа

output --> ['20 3\n', '12 5\n', '4 8 12 7 3 6 2 0 1 17']
```
Поместим данные в один лист и удалим пропуски на концах строк и новые абзацы `\n`

```python
l = [i.rstrip() for i in fin.readlines()]

output --> ['20 3', '12 5', '4 8 12 7 3 6 2 0 1 17']
```

Число всех участников 
```python
n = int(l[0].split()[0])

output --> 20
```
Создам таблицу, куда удобно будет записывать все очки каждого участника

```python
import pandas as pd
df = pd.DataFrame([0]*n)
df.columns =['points']
```
Получаю:

```python
	points
0	0
1	0
2	0
3	0
4	0
5	0
6	0
7	0
8	0
9	0
10	0
11	0
12	0
13	0
14	0
15	0
16	0
17	0
18	0
19	0
```
Выпишем результаты матча 
```python
a_points = int(l[1].split()[0])
b_points = int(l[1].split()[1])
output --> 12
output --> 5
```
Находим модуль разности финального счёта игры и прибавляем к счёту каждого игрока, участвовавшего в матче:

```python
delta = abs(a_points - b_points)
output --> 7
if a_points >= b_points:
  for i in range(5):
    n = int(l[2].split()[i])
    df['points'][n] += delta
else: 
  for i in range(5, 10):
    n = int(l[2].split()[i])
    df['points'][n] += delta
```
Получаем:

```python
	points
0	0
1	0
2	0
3	7
4	7
5	0
6	0
7	7
8	7
9	0
10	0
11	0
12	7
13	0
14	0
15	0
16	0
17	0
18	0
19	0
```
Определим сколько человек опережают Аркадия по очкам:

```python
df[df['points']>df['points'][0]]['points'].count()

output --> 5
```

Мы сделали задачу для одного матча, но количество матчей дано во входящих данных:

```python
m = int(l[0].split()[1])

output --> 3
```

Если даны все строки с результатами и участниками, тогда нужно взять прерыдущий расчёт по количеству сыгранных матчей, то есть:


```python
for j in [i for i in list(range(2*m)) if not i%2]:
  a_points = int(l[j+1].split()[0])
  b_points = int(l[j+1].split()[1])

  delta = abs(a_points - b_points)
  
  if a_points >= b_points:
    for i in range(5):
      n = int(l[j+2].split()[i])
      df['points'][n] += delta
  else: 
    for i in range(5, 10):
      n = int(l[j+2].split()[i])
      df['points'][n] += delta

c = df[df['points']>df['points'][0]]['points'].count()
```
 Если же входных данных нет, то из условия можно сделать следующее:
 
```python
import random

if m > 1:
  for k in range(m-1):
    list_players = random.sample(list(range(n)), 10)
    print(list_players, 'матч', k+2)
    
    a_points = random.randint(0, 20)
    b_points = random.randint(0, 20)
    print (a_points, ' ', b_points)
    
    delta = abs(a_points - b_points)
    
    if a_points >= b_points:
      for i in range(5):
        n = int(list_players[i])
        df['points'][n] += delta
    else: 
      for i in range(5, 10):
        n = int(list_players[i])
        df['points'][n] += delta

c = df[df['points']>df['points'][0]]['points'].count()
```

Для примера получаем таблицу:
 
```python
	points
0	0
1	9
2	0
3	7
4	7
5	6
6	0
7	22
8	22
9	0
10	9
11	0
12	7
13	6
14	9
15	0
16	0
17	0
18	0
19	6
```
 И ответ для данного ввода:
 
```python
c = df[df['points']>df['points'][0]]['points'].count()

output --> 11
```

---
<br>


## Экономный инженер

Молодой инженер Сергей решил накопить денег на новую авиамодель. Подсчитав стоимость всех необходимых ему частей и вычтя их из зарплаты, Сергей понял, что в месяц может потратить не больше 10000 монет. Чтобы следить, что он не тратит слишком много, Сергей решил записывать каждый свой расход и считать, сколько у него останется от 10000 монет, если в оставшееся время он будет тратить в минуту столько же, сколько в среднем тратил до сих пор. Помогите Сергею написать программу, которая будет считать это за него.

**Формат ввода**

На вход подаются от 1 до 10000 строк. Каждая строка имеет формат

`YYYY-MM-DD hh:mm:ss S`

Здесь `YYYY-MM-DD` - год-месяц-число, когда был расход, `hh:mm:ss` - час:минута:секунда, когда был расход, S - количество потраченных монет.

Время расхода `T` изменяется в рамках (`2021-01-01 00:00:00 ≤ T ≤ 2021-01-31 23:59:59`).

Сумма расхода `S` - это целое число: `1 ≤ S ≤ 1000`.

Строки подаются на вход в порядке не убывания времени расхода.

**Формат вывода:**

Для каждой строки на входе необходимо посчитать сумму, которая останется у инженера на момент времени `2021-02-01 00:00:00`, если инженер будет в среднем тратить столько же, сколько тратил до момента времени в строке включительно.

Сумму необходимо округлить банковским методом (например, round() в Python 3.7.3) и записать с двумя цифрами после запятой.

### Пример 1
```
Ввод
2021-01-01 00:00:00 1000
```

```
Вывод
-2678390000.00
```
### Пример 2
```
Ввод
2021-01-31 23:59:59 1000
```

```
Вывод
9000.00
```

### Пример 3
```
Ввод
2021-01-31 23:59:59 1000
2021-01-31 23:59:59 1000
```

```
Вывод
9000.00
8000.00
```

### Пример 4
```
Ввод
2021-01-24 05:59:59 1000
```

```
Вывод
8666.67
```

### **Решение:**

Отроем и сохраним в листе ввходные данные:

```python
fin = open('input_econ.txt', 'r')
list_base = [line.rstrip() for line in fin.readlines()]

output --> ['2021-01-31 23:59:59 1000', '2021-01-31 23:59:59 1000']
```

Импортируем библиотеку для удобства работы с временем (можно без неё, но придётся `split()` строки по разделителям, что очень объёмно)
```python
import datetime

spent_total = 0
total_time = 31*24*60

bank = 10000
spent_total_i = 0
total_time_i = 0
mean_spent_i = 0
total_spent_delta = 0

for i in range(len(list_base)):
	l_dt = list_base[i].split()[0]
    	dt_i = datetime.datetime.strptime(l_dt, '%Y-%m-%d %H:%M:%S')
	days_i = dt_i.day
    	hours_i = dt_i.hour
    	min_i = dt_i.minute
    	sec_i = dt_i.second
	
	time_before = total_time_i
    	total_time_i = ((days_i-1)*24 + hours_i)*60 + min_i + 1
	
    	spent_i = int(list_base[i].split()[1])
    	spent_total_i += spent_i
    
    	mean_before = mean_spent_i
    	mean_spent_i = spent_total_i/total_time_i
	
    	if i == 0:
        	delta_time = 0
    	else: 
        	delta_time = total_time_i - time_before
        
    	spent_delta = mean_before * delta_time
    	total_spent_delta += spent_delta    

delta_time_total = total_time - total_time_i
all_spent = spent_total_i + delta_time_total*mean_spent_i + total_spent_delta
all_spent = round(all_spent, 2)

result = bank - all_spent
result
output --> 8000.0
```
В цикле сохраняем поочерёдно результаты с переносом строк `\n` в каждой итерации и выводим как `output`

Количество дней в цикле сокращено на один по причите того, что сам месяц начинается с 1го числа, но сами сутки не прошли, поэтому число минут за сутки в пером дне месяца рассчитывается как `((day-1)*24 + hours)*60 + minutes + 1` к минуте прибавляем 1 по причине, что минута уже идёт независимо сколько секунд, первая минута любого времени идёт в счёт, хотя формально в дате может стоять `0` или же этой минуте осталась `1` секунда.

С первым вводом (***Пример 1***) ошибка вывода. Для совпадения результатов необходимо учитывать не минуты, а секунды и только в общем времени за весь месяц вычета из общей суммы. То есть необходимо брать `total_time = 31*24*60 (* 60)`, тогда результат будет как на примере `-2678390000.00`

Для вывода можно использовать `f'{result:.2f}'`

---
<br>


## Экономный инженер

Молодой инженер Сергей решил накопить денег на новую авиамодель. Подсчитав стоимость всех необходимых ему частей и вычтя их из зарплаты, Сергей понял, что в месяц может потратить не больше 10000 монет. Чтобы следить, что он не тратит слишком много, Сергей решил записывать каждый свой расход и считать, сколько у него останется от 10000 монет, если в оставшееся время он будет тратить в минуту столько же, сколько в среднем тратил до сих пор. Помогите Сергею написать программу, которая будет считать это за него.

**Формат ввода**

На вход подаются от 1 до 10000 строк. Каждая строка имеет формат

`YYYY-MM-DD hh:mm:ss S`

Здесь `YYYY-MM-DD` - год-месяц-число, когда был расход, `hh:mm:ss` - час:минута:секунда, когда был расход, S - количество потраченных монет.

Время расхода `T` изменяется в рамках (`2021-01-01 00:00:00 ≤ T ≤ 2021-01-31 23:59:59`).

Сумма расхода `S` - это целое число: `1 ≤ S ≤ 1000`.

Строки подаются на вход в порядке не убывания времени расхода.

**Формат вывода:**

Для каждой строки на входе необходимо посчитать сумму, которая останется у инженера на момент времени `2021-02-01 00:00:00`, если инженер будет в среднем тратить столько же, сколько тратил до момента времени в строке включительно.

Сумму необходимо округлить банковским методом (например, round() в Python 3.7.3) и записать с двумя цифрами после запятой.

### Пример 1
```
Ввод
2021-01-01 00:00:00 1000
```

```
Вывод
-2678390000.00
```
### Пример 2
```
Ввод
2021-01-31 23:59:59 1000
```

```
Вывод
9000.00
```

### Пример 3
```
Ввод
2021-01-31 23:59:59 1000
2021-01-31 23:59:59 1000
```

```
Вывод
9000.00
8000.00
```

### Пример 4
```
Ввод
2021-01-24 05:59:59 1000
```

```
Вывод
8666.67
```

### **Решение:**







```python
c = df[df['points']>df['points'][0]]['points'].count()

output --> 11
```


```python
c = df[df['points']>df['points'][0]]['points'].count()

output --> 11
```


```python
c = df[df['points']>df['points'][0]]['points'].count()

output --> 11
```































